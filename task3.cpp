/* Задание 3. Сравнение производительности последовательных и параллельных сортировок

Данная программа предназначена для тестирования и сравнения скорости выполнения
трёх классических алгоритмов сортировки: пузырьком, выбором и вставками.
Для каждой сортировки реализованы две версии: последовательная и параллельная
с использованием OpenMP (для пузырька и выбора). Сортировка вставками
оставлена последовательной, так как полная параллельная реализация
труднодостижима из-за зависимостей элементов.

Программа создаёт массивы случайных чисел трёх разных размеров
(1000, 5000, 10000 элементов) и замеряет время выполнения каждой версии
сортировки с помощью библиотеки <chrono>. Результаты выводятся в консоль,
что позволяет наглядно сравнить эффективность параллельного выполнения.
*/

//пример команды для запуска кода:
//g++ -fopenmp -O2 -std=c++17 task3.cpp -o task3.exe
// $env:OMP_NUM_THREADS = '4'        
// .\task3.exe   

#include <iostream>     // Для cout, endl
#include <vector>       // Для контейнера vector
#include <cstdlib>      // Для rand() и srand()
#include <chrono>       // Для измерения времени
#include <omp.h>        // Для OpenMP
using namespace std;    // Использование стандартного пространства имен

// Функция генерации случайного массива
vector<int> generateArray(int size) {
    vector<int> arr(size);                  // Создаем вектор заданного размера
    for (int i = 0; i < size; ++i) {        // Проходим по всем элементам
        arr[i] = rand() % 100000;           // Заполняем случайными числами от 0 до 99999
    }
    return arr;                             // Возвращаем сгенерированный массив
}

// Последовательные версии 

// Сортировка пузырьком (последовательно)
void bubbleSort(vector<int>& arr) {
    int n = arr.size();                      // Длина массива
    for (int i = 0; i < n-1; ++i) {         // Внешний проход
        for (int j = 0; j < n-i-1; ++j) {   // Сдвигаем максимальное значение вправо
            if (arr[j] > arr[j+1]) {        
                swap(arr[j], arr[j+1]);     // Меняем соседние элементы местами
            }
        }
    }
}
// Сортировка выбором (последовательно)
void selectionSort(vector<int>& arr) {
    int n = arr.size();                      // Длина массива
    for (int i = 0; i < n-1; ++i) {         // Фиксируем текущую позицию минимального элемента
        int minIndex = i;                    // Индекс текущего минимума
        for (int j = i+1; j < n; ++j) {     // Ищем минимум в оставшейся части
            if (arr[j] < arr[minIndex])     
                minIndex = j;                // Обновляем индекс минимального элемента
        }
        swap(arr[i], arr[minIndex]);         // Меняем найденный минимум с текущим элементом
    }
}

// Сортировка вставками (последовательно)
void insertionSort(vector<int>& arr) {
    int n = arr.size();                      // Длина массива
    for (int i = 1; i < n; ++i) {           // Начинаем со второго элемента
        int key = arr[i];                    // Сохраняем текущий элемент
        int j = i-1;                         
        while (j >= 0 && arr[j] > key) {     // Сдвигаем элементы вправо до подходящей позиции
            arr[j+1] = arr[j];               
            --j;                             
        }
        arr[j+1] = key;                      // Вставляем ключ на найденную позицию
    }
}

//  Параллельные версии 

// Пузырьковая сортировка с OpenMP
void bubbleSortParallel(vector<int>& arr) {
    int n = arr.size();                      
    for (int i = 0; i < n-1; ++i) {         
        #pragma omp parallel for             // Параллельный внутренний цикл
        for (int j = 0; j < n-i-1; ++j) {   
            if (arr[j] > arr[j+1])          
                swap(arr[j], arr[j+1]);     // Меняем элементы местами в многопоточной среде
        }
    }
}

// Параллельная сортировка выбором с разделением поиска минимума
void selectionSortParallel(vector<int>& arr) {
    int n = arr.size();                      
    for (int i = 0; i < n-1; ++i) {         
        int minIndex = i;                    

        #pragma omp parallel                  // Создаем параллельную область
        {
            int localMin = minIndex;          // Локальный минимум для каждого потока

            #pragma omp for nowait            // Делим цикл между потоками без ожидания
            for (int j = i+1; j < n; ++j) {
                if (arr[j] < arr[localMin])   
                    localMin = j;            // Сохраняем локальный минимум
            }

            #pragma omp critical              // Критическая секция для обновления глобального минимума
            if (arr[localMin] < arr[minIndex])
                minIndex = localMin;         
        }

        swap(arr[i], arr[minIndex]);          // Меняем найденный минимум с текущим элементом
    }
}

// Параллельная версия вставки технически оставляется последовательной
void insertionSortParallel(vector<int>& arr) {
    insertionSort(arr);                                // просто вызываем последовательную
}


//  Главная функция//

int main() {
     srand(time(0));                            // Инициализация генератора случайных чисел

    vector<int> sizes = {1000, 5000, 10000};   // Размеры массивов для теста

    for (int size : sizes) {                    // Проходим по каждому размеру массива
        vector<int> arr = generateArray(size); // Генерация исходного массива случайных чисел

        cout << "\nРазмер массива: " << size << endl;


        // Сортировка Пузырьком

        vector<int> arrSeq = arr;                            // Копируем исходный массив в новый вектор для последовательной сортировки, чтобы не изменять оригинал
        auto start = chrono::high_resolution_clock::now();  // Засекаем время начала выполнения сортировки
        bubbleSort(arrSeq);                                 // Вызываем функцию последовательной сортировки пузырьком
        auto end = chrono::high_resolution_clock::now();    // Засекаем время окончания выполнения сортировки
        chrono::duration<double> durationSeq = end - start; // Вычисляем длительность выполнения сортировки (разница между start и end)
        cout << "Сортировка пузырьком последовательная: " << durationSeq.count() << " сек" << endl; // Выводим время выполнения в секундах

        vector<int> arrPar = arr;                           // Копируем исходный массив в новый вектор для параллельной сортировки
        start = chrono::high_resolution_clock::now();       // Засекаем время начала параллельной сортировки
        bubbleSortParallel(arrPar);                          // Вызываем функцию параллельной сортировки пузырьком с использованием OpenMP
        end = chrono::high_resolution_clock::now();         // Засекаем время окончания выполнения параллельной сортировки
        chrono::duration<double> durationPar = end - start; // Вычисляем длительность выполнения параллельной сортировки
        cout << "Сортировка пузырьком параллельная: " << durationPar.count() << " сек" << endl;  // Выводим время выполнения параллельной сортировки

        // Сортировка Выбором
        arrSeq = arr;                                        // Копируем исходный массив для последовательной сортировки выбором
        start = chrono::high_resolution_clock::now();        // Засекаем время начала сортировки выбором
        selectionSort(arrSeq);                               // Вызываем последовательную сортировку выбором
        end = chrono::high_resolution_clock::now();          // Засекаем время окончания выполнения сортировки
        cout << "Сортировка выбором последовательная: " 
            << chrono::duration<double>(end - start).count() << " сек" << endl; // Выводим время выполнения последовательной сортировки выбором

        arrPar = arr;                                        // Копируем исходный массив для параллельной сортировки выбором
        start = chrono::high_resolution_clock::now();        // Засекаем время начала параллельной сортировки выбором
        selectionSortParallel(arrPar);                       // Вызываем параллельную сортировку выбором с OpenMP
        end = chrono::high_resolution_clock::now();          // Засекаем время окончания выполнения параллельной сортировки
        cout << "Сортировка выбором параллельная: " 
            << chrono::duration<double>(end - start).count() << " сек" << endl; // Выводим время выполнения параллельной сортировки выбором

        // Сортировка вставкой
        arrSeq = arr;                                         // Копируем исходный массив для последовательной сортировки вставками
        start = chrono::high_resolution_clock::now();         // Засекаем время начала сортировки вставками
        insertionSort(arrSeq);                                // Вызываем последовательную сортировку вставками
        end = chrono::high_resolution_clock::now();           // Засекаем время окончания сортировки
        cout << "Сортировка вставкой последовательная: " << chrono::duration<double>(end - start).count() << " сек" << endl; // Выводим время выполнения

        arrPar = arr;                                         // Копируем исходный массив для "параллельной" версии вставки (технически последовательная)
        start = chrono::high_resolution_clock::now();         // Засекаем время начала
        insertionSortParallel(arrPar);                        // Вызываем "параллельную" сортировку вставками (просто вызывает последовательную функцию)
        end = chrono::high_resolution_clock::now();           // Засекаем время окончания
        cout << "Сортировка вставкой параллельная: " << chrono::duration<double>(end - start).count() << " сек" << endl; // Выводим время выполнения

        } // конец цикла по размерам массивов

        return 0;            // Завершение программы, выход из main
