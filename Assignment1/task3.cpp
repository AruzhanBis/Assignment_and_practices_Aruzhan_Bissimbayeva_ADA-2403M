/* 3. Цель программы:
        1) Создать массив из 1 000 000 случайных целых чисел (шаг из задания 2).
        2) Найти минимальный и максимальный элементы двумя способами:
            – последовательно (обычный цикл)
            – параллельно с использованием OpenMP
        3) Измерить и сравнить время выполнения двух реализаций.

        Теоретические замечания:
            –последовательный поиск min/max имеет сложность O(N)
            –при параллельном поиске участки массива распределяются между потоками
            –каждый поток ищет свой локальный min/max
            –далее выполняется редукция (сравнение локальных min/max)

            код для запуска в терминале:
            g++ -fopenmp task3.cpp -o task3.exe
            .\task3.exe           */

#include <iostream>              // подключаем стандартный ввод/вывод
#include <cstdlib>               // rand(), srand()
#include <ctime>                 // time()
#include <chrono>                // замер времени
#include <omp.h>                 // библиотека OpenMP

int main()                       // точка входа
{
    const int N = 1000000;       // размер массива (1 миллион)
    int* arr = new int[N];       // выделение памяти под массив

    srand(time(nullptr));        // инициализация генератора случайных чисел

    for(int i = 0; i < N; i++)   // цикл для заполнения массива значениями
    {
        arr[i] = rand() % 1000000; // присваиваем случайное число между 0 и 999999
    }

    // Последовательный поиск

    auto start_seq = std::chrono::high_resolution_clock::now(); // время начала

    int minSeq = arr[0];        // инициализируем минимум значением первого элемента
    int maxSeq = arr[0];        // инициализируем максимум значением первого элемента

    for(int i = 1; i < N; i++)  // перебор массива
    {
        if(arr[i] < minSeq)     // если элемент меньше текущего минимума
            minSeq = arr[i];    // обновляем минимум

        if(arr[i] > maxSeq)     // если элемент больше текущего максимума
            maxSeq = arr[i];    // обновляем максимум

    }

    auto end_seq = std::chrono::high_resolution_clock::now(); // фиксируем время начала параллельного поиска
    std::chrono::duration<double> seq_time = end_seq - start_seq; // вычисление длительности

    // Параллельный поиск

    auto start_par = std::chrono::high_resolution_clock::now(); // старт таймера

    int minPar = arr[0];        // глобальный параллельный min
    int maxPar = arr[0];        // глобальный параллельный max

    #pragma omp parallel        // запуск параллельного региона OpenMP
    {
        int localMin = minPar;  // локальная переменная min, хранит значение для конкретного потока
        int localMax = maxPar;  // локальная переменная max, хранит значение для конкретного потока

        #pragma omp for nowait  // распределяем цикл между потоками
        for(int i = 1; i < N; i++)
        {
            if(arr[i] < localMin)   // проверяем, меньше ли текущий элемент локального минимума
                localMin = arr[i];  // обновляем локальный минимум

            if(arr[i] > localMax)   // проверяем, больше ли текущий элемент локального максимума
                localMax = arr[i];  // обновляем локальный максимум
        }

        #pragma omp critical     // защищаем доступ к общим переменным
        {
            if(localMin < minPar)   // если локальный минимум меньше глобального
                minPar = localMin;  // обновляем глобальный минимум

            if(localMax > maxPar)   // если локальный максимум больше глобального
                maxPar = localMax;  // обновляем глобальный максимум
        }
    }

    auto end_par = std::chrono::high_resolution_clock::now();       // фиксируем окончание параллельного поиска
    std::chrono::duration<double> par_time = end_par - start_par;   // вычисляем время параллельного поиска

    // Вывод результатов

    std::cout << "Вывод:" << std::endl;                          // заголовок вывода

    std::cout << "Последовательный поиск:" << std::endl;         // надпись для последовательного поиска
    std::cout << "min = " << minSeq << std::endl;                // вывод минимального значения
    std::cout << "max = " << maxSeq << std::endl;                // вывод максимального значения
    std::cout << "Время = " << seq_time.count() << " сек." << std::endl;  // вывод времени поиска

    std::cout << std::endl;                                      // пустая строка

    std::cout << "Параллельный поиск (OpenMP):" << std::endl;    // надпись для параллельного поиска
    std::cout << "min = " << minPar << std::endl;                // вывод параллельного минимального значения
    std::cout << "max = " << maxPar << std::endl;                // вывод параллельного максимального значения
    std::cout << "Время = " << par_time.count() << " сек." << std::endl; // вывод времени поиска

    delete[] arr;      // освобождаем динамически выделенную память

    return 0;          // завершение работы программы
}

