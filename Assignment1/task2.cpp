/*  2. Данная программа демонстрирует:  
        1) динамическое выделение памяти под массив размером 1 000 000 целых чисел  
        2) заполнение массива случайными числами  
        3) последовательный поиск минимального и максимального элементов  
        4) замер времени выполнения поиска min/max  
        5) корректное освобождение выделенной памяти  

        Поиск выполняется линейным обходом массива: O(N).  */   


#include <iostream>          // подключение библиотеки стандартного ввода-вывода
#include <cstdlib>           // библиотека для функций rand(), srand()
#include <ctime>             // для функции time(), чтобы инициализировать генератор случайных чисел
#include <chrono>            // библиотека для замера времени выполнения

int main()                   // точка входа в программу
{
    const int N = 1000000;   // объявляем константу N – размер массива (1 миллион)

    std::cout << "Выделение памяти под массив..." << std::endl; 
    int* arr = new int[N];   // выделяем память динамически под массив из N элементов

    std::cout << "Память выделена." << std::endl; 

    srand(time(nullptr));    // инициализируем rand случайным seed на основе текущего времени

    std::cout << "Заполнение массива случайными значениями..." << std::endl;
    for(int i = 0; i < N; i++)   // цикл от 0 до N-1
    {
        arr[i] = rand() % 1000000;   // генерируем и записываем случайное число 0-999999
    }
    std::cout << "Массив заполнен." << std::endl;

    std::cout << "Начало поиска минимума и максимума..." << std::endl;

    auto start = std::chrono::high_resolution_clock::now(); // фиксируем стартовое время

    int minVal = arr[0];      // задаем начальное значение минимума
    int maxVal = arr[0];      // задаем начальное значение максимума

    for(int i = 1; i < N; i++) // цикл последовательного просмотра массива с 1-го элемента
    {
        if(arr[i] < minVal)   // если текущий элемент меньше min,
            minVal = arr[i];  // то обновляем минимум

        if(arr[i] > maxVal)   // если текущий элемент больше max,
            maxVal = arr[i];  // то обновляем максимум
    }

    auto end = std::chrono::high_resolution_clock::now(); // фиксируем время завершения поиска

    std::chrono::duration<double> elapsed = end - start;  // вычисляем длительность поиска

    std::cout << "Поиск завершён." << std::endl;

    std::cout << "Минимальный элемент массива: " << minVal << std::endl;   // вывод min
    std::cout << "Максимальный элемент массива: " << maxVal << std::endl;   // вывод max
    std::cout << "Время поиска: " << elapsed.count() << " секунд" << std::endl; // вывод времени

    std::cout << "Освобождение памяти..." << std::endl;
    delete[] arr;             // освобождаем память, выделенную оператором new[]

    std::cout << "Память освобождена." << std::endl;
   
    return 0;                 // успешное завершение программы
}
